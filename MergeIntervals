Merge Intervals

Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, 
and return an array of the non-overlapping intervals that cover all the intervals in the input.
Example 1:

Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].
Example 2:

Input: intervals = [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
Example 3:

Input: intervals = [[4,7],[1,4]]
Output: [[1,7]]
Explanation: Intervals [1,4] and [4,7] are considered overlapping.
 

Constraints:

1 <= intervals.length <= 104
intervals[i].length == 2
0 <= starti <= endi <= 104

SOLUTION1:

/**
 * @param {number[][]} intervals
 * @return {number[][]}
 */
var merge = function(intervals) {
    if(!intervals) return [];

    intervals.sort((a,b)=>a[0] - b[0]);
    let n = intervals.length;
    let mergedArr = [intervals[0]];
    let m = mergedArr.length;

    for(let i = 1; i<n; i++){
        let curr = intervals[i];
        let prev = mergedArr[m - 1];

        if(curr[0] <= prev[1] ){
            prev[1] = Math.max(prev[1], curr[1]);
        } else {
            mergedArr.push(curr);
        }

    }
    return mergedArr
    
};

CHATGPT SOLUTION:
var merge = function(intervals) {
    if (intervals.length === 0) return [];

    // Step 1: Sort by start time
    intervals.sort((a, b) => a[0] - b[0]);

    // Start result with the first interval wrapped in an array
    let mergedArr = [intervals[0]];

    for (let i = 1; i < intervals.length; i++) {
        let curr = intervals[i];
        let prev = mergedArr[mergedArr.length - 1]; // last merged interval

        if (curr[0] <= prev[1]) {
            // Overlap → merge
            prev[1] = Math.max(prev[1], curr[1]);
        } else {
            // No overlap → push
            mergedArr.push(curr);
        }
    }

    return mergedArr;
};


SOLUTION 2:
function merge(intervals) {
  // sort intervals by start
  intervals.sort((a, b) => a[0] - b[0]);

  let result = [];

  for (let interval of intervals) {
    // if result empty OR no overlap → push
    if (result.length === 0 || result[result.length - 1][1] < interval[0]) {
      result.push(interval);
    } else {
      // overlap → merge (update the end time)
      result[result.length - 1][1] = Math.max(result[result.length - 1][1], interval[1]);
    }
  }

  return result;
}

// Example runs:
console.log(merge([[1,3],[2,6],[8,10],[15,18]])); // [[1,6],[8,10],[15,18]]
console.log(merge([[1,4],[4,5]]));               // [[1,5]]
console.log(merge([[4,7],[1,4]]));               // [[1,7]]








